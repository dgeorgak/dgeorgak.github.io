[
  
  {
    "title": "One more way to copy large files to and from lhost",
    "url": "/posts/one-more-way-to-copy-large-files-to-and-from-lhost/",
    "categories": "Tips, CTF",
    "tags": "ctf, pentest, copy_file",
    "date": "2025-01-12 00:00:00 +0000",
    





    
    "snippet": "Lets say that you found a large .bak file in the rhost and you want to copy it to your lhost for investigation purposes.Or you need to copy a script to the rhost and fire it up for your exploit to ...",
    "content": "Lets say that you found a large .bak file in the rhost and you want to copy it to your lhost for investigation purposes.Or you need to copy a script to the rhost and fire it up for your exploit to take effect.And in both of these cases there are no tools present that might prove useful to do such a thing.The solution provided in this post will work both directions, and it works by encoding said file(s) as base64.For this scenario we will copy /etc/passwd of our target to our own lhost.  In the rhost run base64 /etc/passwd &gt; b64_passwd This will encode /etc/passwd and pass the encoded text to the file b64_passwd  Open b64_passwd in a text editor (eg nano) and copy the whole text  On your lhost paste the copied text to a new file b64_passwd2  Then run base64 -d b64_passwd2 &gt; obtained_passwd This command will decode the contents of the b64_passwd2 file and pass the resulting text to obtained_passwd  Now you have the contents of rhost’s /etc/passwd file on your own obtained_passwd fileFor the next scenario we will copy linpeas.sh from our lhost to the rhost.  This could be done manually by following the instructions above, but this time encoding our local file, copying its contents over to the rhost, and encoding there.The problem in this case is that linpeas.sh will result in a very long base64 text which will make it difficult and error prone to paste it piece by piece.  To solve this, we will automate the part of copying the encoded text to our clipboard, so that we can carry it over to the rhost by pasting only once.For this reason we will use xclip.  If not already present, you can install it by running sudo apt install xclip (or the equivalent of your distro).The steps for this case are the following:  Run base64 /opt/linpeas/linpeas.sh | xclip -selection clipboard This command will encode linpeas.sh, and pipe it to our clipboard  On rhost paste to a new file (eg b64_lp)  Now run base64 -d b64_lp &gt; linpeas.sh  linpeas.sh is now available in rhost"
  },
  
  {
    "title": "A quick and easy web server",
    "url": "/posts/a-quick-and-easy-web-server/",
    "categories": "Tools, webserver",
    "tags": "ctf, pentest, intro, web-server",
    "date": "2025-01-11 00:00:00 +0000",
    





    
    "snippet": "There are many reasons why a pentester would want to quickly fire up a web server.Imagine having gained access to a machine, and now you need to upload a payload or a script.  You could try messing...",
    "content": "There are many reasons why a pentester would want to quickly fire up a web server.Imagine having gained access to a machine, and now you need to upload a payload or a script.  You could try messing around with file transfer protocols.  But it would be much easier to just use a one-liner and spin up a quick HTTP server.The reverse scenario is also true.  Sometimes, you’ve got to exfiltrate files.  Maybe it’s sensitive data or just something that proves you’ve achieved your objective.  Hosting a server makes this super easy.  You just grab what you need, pull it over HTTP, and you’re done.  Simple and clean.Another scenario can be a staging environment.  Ever needed to have a fake site up and running for phishing purposes?  A quick server makes that painless.  You can set it up right there, test how things look, and tweak it if needed.  It’s way faster than setting up a full-blown environment.Or maybe it’s just about testing stuff.  Having your own web server running lets you try things out without needing to rely on anything external.  Plus, most of these servers log requests for you, so you can see exactly what’s happening.So let your imagination free and set up an easy web server for your own purposes!  Fire up a python http.server and you’re good to…wait, what?…no python!?Fret not!  There are many ways to have a web server running depending on the programming languages available on your local (or remote) host.Here’s a few of them:  Python:  python -m http.server 8000  PHP:php -S 127.0.0.1:8000  Node.js:  npx http-server ./ --port 8000  Rust:  cargo install miniserve &amp;&amp; miniserve -p 8000 .  Ruby:  ruby -run -e httpd ./ -p 8000  BusyBox:  busybox httpd -f -p 8000  Caddy:  caddy file-server  R:  Rscript -e 'servr::httd()' -p 8000"
  },
  
  {
    "title": "CTF vs Pentest engagement",
    "url": "/posts/CTF-vs-Pentest-engagement/",
    "categories": "Thinking out loud",
    "tags": "ctf, pentest, intro, enumeration",
    "date": "2024-09-18 00:00:00 +0000",
    





    
    "snippet": "One of the common misconceptions for new people joining the pentesting community is that a CTF emulates a real pentest engagement.  And it makes sense, because a CTF is among the first things that ...",
    "content": "One of the common misconceptions for new people joining the pentesting community is that a CTF emulates a real pentest engagement.  And it makes sense, because a CTF is among the first things that an aspiring penetration tester tackles that gives them a sample of the experience that is a pentest.  This is what they know.  This is also what I used to know, before I got a real glimpse of the actual and professional process that is a penetration test.And even though CTFs are one of the ways through which one can build up a skillset with regards to hacking and penetration testing (I will dwell upon this subject on another post), I am not challenging their usefulness here.  What I aim to build upon is how the ways of resolving a CTF challenge differ from the process of approaching a penetration test.  And when referring to CTFs I will be focusing on the black box challenges that the aspiring hacker goes through in order to break into a server (or a number of), gain a foothold, elevate privileges and obtain root or SYSTEM level access.a vulnerability gameYou see, the process of a CTF is mainly following a pattern.  The attacker, initiating the attack externally, scans the network for potential targets.  More often than not, they are even provided with the IP of the target to begin with.  With the target IP address(es) at hand they can start scanning the target for exposed ports.  This will give them an idea of what they are dealing with.  Services, versions, OS, maybe a frontend to start investigating.  Through their findings they will gain an idea on how to approach the challenge, probable attack vectors, maybe a CVE that might prove useful.  The aim at this point is to find the vulnerability on the target that will help them gain a foothold, even if it’s just a low privilege user (it usually is).A small sidenote here.  As CTFs are built as a techy-puzzle that the attacker needs to solve, the vulnerability is often just the single one that the CTF creator decided to integrate in their lab in order to make it “vulnerability X” specific.  This is an important aspect of CTFs and I will return to this point further down in my post.After surveying the land, abusing a vulnerability and managing to gain access to the server, the CTF player will once more need to investigate their surroundings.  This time from an inside perspective.  They could check for sudo permissions, SUID or GUID misconfigurations, credentials/keys/tokens lying around somewhere in the system, services that they could not access from the outside, etc.  That will allow them to go down one of the two following paths with the aim to find the user flag.  Either move laterally to another user, or even another host, or elevate privileges.In the case of the former, they will have to pay their investigation dues all over again in order gain findings that the new user has access to and the previous one did not, or that the new host offers that were not available in their first one.In the case of the latter (and the latter one will eventually come at some point, even if the player needs to go through several lateral movements) upon successfully elevating privileges, it’s game over.  You have access to the root flag.  “You win”.a security assessmentA penetration test does not start with the pentester immediately attacking the targets in order to break into their systems.  There is no certain way in, and the aim is not to find “the one” way in.  There are varying circumstances, terms, limitations, requirements.  There is an actual running company on the other side, and that is the target.  The priority of the penetration tester is to protect them.  Protect them through the assessment’s findings, as well as during the assessment.The penetration testers, together with the client, they scope the target and set the rules of engagement.  That might include specific time frame and time-slots for the engagement, rate limiting for automated tools, which parts/assets of the target must be tested and which are considered as out of bounds.  There will be a contact person appointed that the pentesters can reach out to in case of urgent matters (the assessment leading to unwanted disruptions on the target’s operations, a critical finding that needs to be communicated immediately, etc).  There might be vendors that the client is using to provide their services, that could be defined as out of scope.  And it is only within the boundaries that these terms set that the penetration testers will operate upon.Still, even with the target scoped out, the penetration testers need to confirm that the IPs belong to their client.  If any discrepancies are found they need to be communicated with the client to resolve any issues.The assessment then can start with an external automated scan.  The penetration testers then can follow up with manually testing any promising findings, as well as points in the target that could prove to be critical if they are not properly secured (eg, login pages, file upload functionalities, API endpoints returning PII or S3 buckets containing them, etc).All of this however is done after taking into account the time limitations.  The assessment cannot run indefinitely.  There are specific start and end dates.  So the pentesting team need to prioritise according to the risk that each asset or feature poses.  There is an external facing login page that gives access to critical information?  That’s a high priority.  There is an internal static webpage, totally isolated from outside the client’s organisation?  Best to tackle other assets first and just leave that to be tested by automated tools.During a penetration test the pentesters will not necessarily be successful on breaking into the client’s systems.  It is most common that they will not.  For the client to rest assured that their product and network has been thoroughly tested, the penetration testers might be provided with credentials of either low privileges, or even admin credentials.  Depending on the type of the target (webapp, infrastructure, cloud, mobile app) that might happen so that the pentesting team checks if as a low privileged user they cannot gain unauthorised access to higher level privileges, or even access to data of another same level user.They might even be given access to the client’s repository, for conducting code review, pinpointing the product’s vulnerabilities even before they interact with it, making it a white-box engagement.It is common to also check in platforms like haveIBeenPwned.com, deHashed.com or intelX.io for leaked credentials that concern the client, for which the client needs to be made aware of.And after everything is done, and depending on what processes they followed, the pentesting team need to clean up any running processes , malicious payloads and accounts that were initiated by them. The point of the assessment is that every security issue, every vulnerability, every authorisation and authentication bypass, every concern is a finding.  And once everything is done, all of the findings need to go in a report as a deliverable to the client.  This needs to include an overview of the findings, their severity, the steps to reproduce them, and remediation suggestions.  It is also common that more than one reports are delivered.  One for the technical department to go through, with elaborate steps to reproduce each issue, as well as remediation actions.  One for the management, with information that concerns them, like a high level explanation of the assessment, the number of findings, a short explanation and severity of each finding along with the risk that comes with it.  And depending on the client’s organisation, a report might be prepared so that the client can share the findings with their own clients (without providing any critical details), as an affirmation that they commit to keeping a high standard of security.  And in many cases there is one more clause in the agreement, that is about the pentesting team retesting their findings once the client has marked them as fixed.  The deliverables are also reviewed in that case, updating the resolution of each finding.the game vs the assessmentBy now it should be obvious that CTFs and penetration tests differ a lot.A CTF is meant to be beaten.  There is a way to win.  Often it is “the way you are supposed to win”.  You just need to find it, and often you can take your time with it.  Then you usually gain points and/or bragging rights.  You also gain knowledge and experience of the specific vulnerability and attack vector you used in order to gain your flags.  If you want you can even write a walkthrough so that other people can go through each step you took, or you might decide not to bother with it.  It is not required, as the flags themselves are the actual proof that you beat the game.A penetration test does not involve “one way” to break into the client’s systems.  You have to find all the weak spots in the client’s assets and all of them are considered findings, no matter if they are critical or not.  You have to respect the boundaries that the client lays out in the rules of engagement.  Be that the time of the engagement, the access rights (or lack thereof), the scope, and all the needs and wants of the client.  And in the end you need to list all your findings, along with any details supporting them in a way that is useful to the client.  Because the report is what the client expects from the assessment."
  },
  
  {
    "title": "feroxbuster",
    "url": "/posts/feroxbuster/",
    "categories": "Tools, feroxbuster",
    "tags": "hidden directory, scanning, intro, enumeration",
    "date": "2024-05-29 00:00:00 +0000",
    





    
    "snippet": "Imagine the following target: https://www.myexampletarget.com.  Now imagine that somewhere in there is an admin page that presents a login screen that is susceptible to SQLi, and as a bonus it show...",
    "content": "Imagine the following target: https://www.myexampletarget.com.  Now imagine that somewhere in there is an admin page that presents a login screen that is susceptible to SQLi, and as a bonus it showcases the version of the webapp behind it.  The login page’s url is https://www.myexampletarget.com/dev/pages/member.admin.But there is one caveat.  You do not know about it.  You do not know the url of the admin page, the login page, the fact that a webapp is hidden somewhere in this website.  You only know the target’s url.  Also, the page is hidden.  There is no link path leading to the specific page so spidering will not you help here.Tough?  Well, not so much.  There are tools that help in discovering hidden directories under a subdomain.  Some famous ones are dirbuster, dirb and gobuster.  Another one is feroxbuster, and this is the one that we are going to talk about here. Feroxbuster takes in a url target and a wordlist and applies each word in the wordlist as a directory under the specific url.  For every successful directory it finds, it adds another layer of scanning for subdirectories under the directory that was just found.  On top of that it is very customise-able in terms of how deep we want it to scan, if we also need it to scan for files with specific extensions, how many concurrent scans we allow it to run, if it should follow redirects, etc.Coming back to our example target above, lets assume that we found https://www.myexampletarget.com behind port 8080.  In order to fire up feroxbuster we run the following command: feroxbuster --url http://www.myexampletarget.com:8080 -w directory-wordlist.txt--url is used to provide the url target.  If needed we can also specify the port by appending :port# at the end-w defines the wordlist that we will be using in order to uncover directoriesThis is the simplest command we can run with feroxbuster.  The good thing is that we can customise it as much as we’d like.In our case, our customer was explicit about the fact that the directory /vendor is out of bounds during our engagement.--dont-scan /vendor will instruct feroxbuster to not touch the specific directoryWhat if we want to also keep an eye in case there are any interesting files in any of the discovered directories.-x .pdf will inform us if any pdf files are present within the directories that the tool listsWhile feroxbuster is running we receive a lot of 404 responses which clutter up our results.-C 404 can be used to filter out the status code 404"
  },
  
  {
    "title": "nmap intro",
    "url": "/posts/nmap-intro/",
    "categories": "Tools, nmap",
    "tags": "nmap, scanning, intro, reconnaissance, enumeration",
    "date": "2024-05-26 00:00:00 +0000",
    





    
    "snippet": "So you have a target IP and want to scan for open ports.If you have no knowledge of nmap then I would suggest to go through its man pages (as you should for any cli tool), but in the meantime you c...",
    "content": "So you have a target IP and want to scan for open ports.If you have no knowledge of nmap then I would suggest to go through its man pages (as you should for any cli tool), but in the meantime you can use this specific command to -hopefully- get some quick results.nmap target-IPThis is the most basic of scans that nmap can do.So what does this do?It scans the target IP’s top 1000 ports to see if any of them are responsive.  If they are, then they will be marked as open (a service is actively listening on this port), or filtered (the port is blocked, eg by a firewall).  The rest will be marked as closed.An indicative output would be such as the one below, listing the number of each port, its status and its respective service:Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-01-14 12:00 UTCNmap scan report for 10.10.145.33Host is up (0.00012s latency).Not shown: 996 closed tcp ports (conn-refused)PORT    STATE    SERVICE22/tcp  open     ssh80/tcp  filtered http443/tcp open     https21/tcp  open     ftpNmap done: 1 IP address (1 host up) scanned in 0.12 secondsAll this is fine, but what if you want more details?What if you want to know the version of each service?  The OS running on the target?  Or even potentially start collecting security misconfigurations?Then add the following flags in your command: nmap -T4 -A -p- target-IP  -T4 defines the speed at which nmap runs the scan.  You can pick any option between -T0 (slowest) to -T5 “fastest”.  But be aware about the fact that the faster the scan runs, the easier it gets for your scan to be detected.  -A, also known as “Aggressive” scan, is used to detect service versions, the underlying OS, runs scripts to gather additional info and performs a traceroute.  This option makes your activities very “loud”, which in turn makes it easy for intrusion detection systems to notice your scanning the system.  -p- means that you ask nmap to scan all (65535) ports rather than the top 1000 which are scanned by default.The output that these flags can generate can become very complex, depending on the findings.  As mentioned earlier this is not only presenting the ports found, but also their versions and any other information that could be retrieved, the operating system of the target, and the results of the tests run by the nmap scripts.The example below could be the result of scanning a target:Starting Nmap 7.91 ( https://nmap.org ) at 2023-10-04 13:22 UTCNmap scan report for 10.10.228.174 (10.10.228.174)Host is up (0.076s latency).Not shown: 65532 closed portsPORT   STATE SERVICE VERSION21/tcp open  ftp     vsftpd 3.0.3| ftp-anon: Anonymous FTP login allowed (FTP code 230)|_-rw-r--r--    1 0        0             119 May 17  2020 note.txt| ftp-syst: |   STAT: | FTP server status:|      Connected to ::ffff:10.14.13.255|      Logged in as ftp|      TYPE: ASCII|      No session bandwidth limit|      Session timeout in seconds is 300|      Control connection is plain text|      Data connections will be plain text|      At session startup, client count was 3|      vsFTPd 3.0.3 - secure, fast, stable|_End of status22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: |   2048 16:7f:2f:fe:0f:ba:98:77:7d:6d:3e:b6:25:72:c6:a3 (RSA)|   256 2e:3b:61:59:4b:c4:29:b5:e8:58:39:6f:6f:e9:9b:ee (ECDSA)|_  256 ab:16:2e:79:20:3c:9b:0a:01:9c:8c:44:26:01:58:04 (ED25519)80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Site doesn't have a title (text/html).Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 726.05 seconds  Before I close this I want to point out one more thing that is important to keep in mind.Every time nmap is called to gather information about a host (or a set of), before it performs the port scan it starts a process of gathering information.  One of theses steps is pinging the target hosts to assess whether they are reachable in the network.   This is done by default.There is a caveat here.  If the network or the target’s defences are set up so as not to respond to ICMP requests, then nmap sees no target to scan.  You see how this can be a problem, right?Thankfully, there is a way to force nmap to treat every target as a live host:nmap -Pn target-IP  -Pn is used to tell nmap to skip the host discovery phase and assume that the target host is online.  Even if ICMP requests are blocked, nmap will still run its scans on the targetI will be making another post elaborating on other available nmap options that might come in handy in your enumeration processes, so come back for more."
  }
  
]

