[
  
  {
    "title": "feroxbuster",
    "url": "/posts/feroxbuster/",
    "categories": "Tools, feroxbuster",
    "tags": "hidden directory, scanning, intro, enumeration",
    "date": "2024-05-29 00:00:00 +0300",
    





    
    "snippet": "Imagine the following target: https://www.myexampletarget.com.  Now imagine that somewhere in there is an admin page that presents a login screen that is susceptible to SQLi, and as a bonus it show...",
    "content": "Imagine the following target: https://www.myexampletarget.com.  Now imagine that somewhere in there is an admin page that presents a login screen that is susceptible to SQLi, and as a bonus it showcases the version of the webapp behind it.  The login page’s url is https://www.myexampletarget.com/dev/pages/member.admin.But there is one caveat.  You do not know about it.  You do not know the url of the admin page, the login page, the fact that a webapp is hidden somewhere in this website.  You only know the target’s url.  Also, the page is hidden.  There is no link path leading to the specific page so spidering will not you help here.Tough?  Well, not so much.  There are tools that help in discovering hidden directories under a subdomain.  Some famous ones are dirbuster, dirb and gobuster.  Another one is feroxbuster, and this is the one that we are going to talk about here. Feroxbuster takes in a url target and a wordlist and applies each word in the wordlist as a directory under the specific url.  For every successful directory it finds, it adds another layer of scanning for subdirectories under the directory that was just found.  On top of that it is very customise-able in terms of how deep we want it to scan, if we also need it to scan for files with specific extensions, how many concurrent scans we allow it to run, if it should follow redirects, etc.Coming back to our example target above, lets assume that we found https://www.myexampletarget.com behind port 8080.  In order to fire up feroxbuster we run the following command: feroxbuster --url http://www.myexampletarget.com:8080 -w directory-wordlist.txt--url is used to provide the url target.  If needed we can also specify the port by appending :port# at the end-w defines the wordlist that we will be using in order to uncover directoriesThis is the simplest command we can run with feroxbuster.  The good thing is that we can customise it as much as we’d like.In our case, our customer was explicit about the fact that the directory /vendor is out of bounds during our engagement.--dont-scan /vendor will instruct feroxbuster to not touch the specific directoryWhat if we want to also keep an eye in case there are any interesting files in any of the discovered directories.-x .pdf will inform us if any pdf files are present within the directories that the tool listsWhile feroxbuster is running we receive a lot of 404 responses which clutter up our results.-C 404 can be used to filter out the status code 404"
  },
  
  {
    "title": "nmap intro",
    "url": "/posts/nmap-intro/",
    "categories": "Tools, nmap",
    "tags": "nmap, scanning, intro, reconnaissance, enumeration",
    "date": "2024-05-26 00:00:00 +0300",
    





    
    "snippet": "So you have a target IP and want to scan for open ports.If you have no knowledge of nmap then I would suggest to go through its man pages (as you should for any cli tool), but in the meantime you c...",
    "content": "So you have a target IP and want to scan for open ports.If you have no knowledge of nmap then I would suggest to go through its man pages (as you should for any cli tool), but in the meantime you can use this specific command to -hopefully- get some quick results.nmap target-IPThis is the most basic of scans that nmap can do.So what does this do?It scans the target IP’s top 1000 ports to see if any of them are responsive.  If they are, then they will be marked as open (a service is actively listening on this port), or filtered (the port is blocked, eg by a firewall).  The rest will be marked as closed.An indicative output would be such as the one below, listing the number of each port, its status and its respective service:Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-01-14 12:00 UTCNmap scan report for 10.10.145.33Host is up (0.00012s latency).Not shown: 996 closed tcp ports (conn-refused)PORT    STATE    SERVICE22/tcp  open     ssh80/tcp  filtered http443/tcp open     https21/tcp  open     ftpNmap done: 1 IP address (1 host up) scanned in 0.12 secondsAll this is fine, but what if you want more details?What if you want to know the version of each service?  The OS running on the target?  Or even potentially start collecting security misconfigurations?Then add the following flags in your command: nmap -T4 -A -p- target-IP  -T4 defines the speed at which nmap runs the scan.  You can pick any option between -T0 (slowest) to -T5 “fastest”.  But be aware about the fact that the faster the scan runs, the easier it gets for your scan to be detected.  -A, also known as “Aggressive” scan, is used to detect service versions, the underlying OS, runs scripts to gather additional info and performs a traceroute.  This option makes your activities very “loud”, which in turn makes it easy for intrusion detection systems to notice your scanning the system.  -p- means that you ask nmap to scan all (65535) ports rather than the top 1000 which are scanned by default.The output that these flags can generate can become very complex, depending on the findings.  As mentioned earlier this is not only presenting the ports found, but also their versions and any other information that could be retrieved, the operating system of the target, and the results of the tests run by the nmap scripts.The example below could be the result of scanning a target:Starting Nmap 7.91 ( https://nmap.org ) at 2023-10-04 13:22 UTCNmap scan report for 10.10.228.174 (10.10.228.174)Host is up (0.076s latency).Not shown: 65532 closed portsPORT   STATE SERVICE VERSION21/tcp open  ftp     vsftpd 3.0.3| ftp-anon: Anonymous FTP login allowed (FTP code 230)|_-rw-r--r--    1 0        0             119 May 17  2020 note.txt| ftp-syst: |   STAT: | FTP server status:|      Connected to ::ffff:10.14.13.255|      Logged in as ftp|      TYPE: ASCII|      No session bandwidth limit|      Session timeout in seconds is 300|      Control connection is plain text|      Data connections will be plain text|      At session startup, client count was 3|      vsFTPd 3.0.3 - secure, fast, stable|_End of status22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: |   2048 16:7f:2f:fe:0f:ba:98:77:7d:6d:3e:b6:25:72:c6:a3 (RSA)|   256 2e:3b:61:59:4b:c4:29:b5:e8:58:39:6f:6f:e9:9b:ee (ECDSA)|_  256 ab:16:2e:79:20:3c:9b:0a:01:9c:8c:44:26:01:58:04 (ED25519)80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Site doesn't have a title (text/html).Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 726.05 seconds  Before I close this I want to point out one more thing that is important to keep in mind.Every time nmap is called to gather information about a host (or a set of), before it performs the port scan it starts a process of gathering information.  One of theses steps is pinging the target hosts to assess whether they are reachable in the network.   This is done by default.There is a caveat here.  If the network or the target’s defences are set up so as not to respond to ICMP requests, then nmap sees no target to scan.  You see how this can be a problem, right?Thankfully, there is a way to force nmap to treat every target as a live host:nmap -Pn target-IP  -Pn is used to tell nmap to skip the host discovery phase and assume that the target host is online.  Even if ICMP requests are blocked, nmap will still run its scans on the targetI will be making another post elaborating on other available nmap options that might come in handy in your enumeration processes, so come back for more."
  }
  
]

